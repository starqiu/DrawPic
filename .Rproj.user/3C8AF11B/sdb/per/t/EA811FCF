{
    "contents" : "#! /usr/bin/Rscript --no-save\n#\n#' @author : star qiu\n#' @date 2014.8.1\n#' \n#' \nlibrary(plyr)\nlibrary(foreach)\nlibrary(doParallel)\n\nBASE.PATH <- \"/host/data/\"\n# BASE.PATH <- \"./\"\n# CASE.FILE.PATH <- \"/host/data//sourceData/liver_case_data.txt\"\n# CONTROL.FILE.PATH <- \"/host/data//sourceData/liver_control_data.txt\"\nCASE.FILE.PATH <- NULL\nCONTROL.FILE.PATH <- NULL\n\n\n# FILE.NAME <- \"GSE64538_labeled.txt\"\n# PERIOD.COUNT <- 4 # the number of periods\n# PERIOD.SAMPLE.COUNT <- 3 # the number of samples in every period\n# FEATURES.SD.THRESHOLD <- 0.001 # the threshold of sd to select\n\n\n# FILE.NAME <- \"liver_labeled_data.txt\"\nPERIOD.COUNT <- 5 # the number of periods\nPERIOD.SAMPLE.COUNT <- 5 # the number of samples in every period\nFEATURES.SD.THRESHOLD <- 0.001 # the threshold of sd to select\n\nCLUSTER.HCLUST.H <- 0.75 # the cluster parameter\nPCC.OUT.AMOUNT <- 50 # the number of pcc out we choose to calculate\n\nSTATE <- c(\"case\",\"control\") #case is abnormal,control is normal\nSTATE.COUNT <- 2 #\nCORES <- 6\n\ninit <- function(args){\n  len <- length(args)\n  for (i in seq(1,len,by=2)){\n    set.key.value(args[i],args[i+1])\n  }\n}\n\nset.key.value  <- function(key,value){\n  switch(key,\n         \"-p\" = ,\n         \"--base.path\" = BASE.PATH <<- value,\n         \"--case.file.path\" = CASE.FILE.PATH <<- value,\n         \"--control.file.path\" = CONTROL.FILE.PATH <<- value,\n         \"--period.count\" = PERIOD.COUNT <<- as.integer(value),\n         \"--period.sample.count\" = PERIOD.SAMPLE.COUNT <<- as.integer(value),\n         \"--features.sd.threshold\" = FEATURES.SD.THRESHOLD <<- as.numeric(value),\n         \"--cluster.hclust.h\" = CLUSTER.HCLUST.H <<- as.numeric(value),\n         \"--pcc.out.amount\" = PCC.OUT.AMOUNT <<- as.integer(value),\n         \"--cores\" = CORES <<- as.integer(value)\n  )\n}\n\nprint.usage <- function(){\n  cat(\"Usage: gdm4Par.R [-h/--help |-p/--base.path directory] \\n\n      [-case.file.path file] [-control.file.path file]  \\n\n      [--period.count number] [--period.sample.count number]  \\n\n      [--features.sd.threshold float] [--cluster.hclust.h float] \\n\n      [--pcc.out.amount number] [cores number]\\n\")\n  cat(\"Details:\\n\")\n  cat(\"\\t -h/--help   show the usage of gdm4Par.R \\n\")\n  cat(\"\\t -p/--base.path   set the path of gdm4Par.R . the default value is ./ \\n\")\n  cat(\"\\t --case.file.path   set the path of case data file, case is abnormal data,\\n\n      this file should be in ./sourceData directory.  \\n\")\n  cat(\"\\t --control.file.path   set the path of case data file, control is normal data,\\n\n      this file should be in ./sourceData directory.  \\n\")\n  cat(\"\\t --period.count   set the number of periods  .\n      the default is 5  \\n\")\n  cat(\"\\t --period.sample.count   set the number of samples in every period . \n      the default is 5 \\n\")\n  cat(\"\\t --features.sd.threshold   set the threshold of filtering SD\n      the default is 0.001 \\n\")\n  cat(\"\\t --cluster.hclust.h   set the h value when we call the cutree function\n      the default is 0.75 \\n\")\n  cat(\"\\t --pcc.out.amount  set the max number of the PCC between two modules \n      we select to calculate. the default is 50 \\n\")\n  cat(\"\\t --cores  set the number of cores we use for parallel program \n      the default is 6 \\n\")\n  cat(\"Description:\\n\")\n  cat(\"\\t  if -h/--help is appeared,the other parameters is ignored. \n      \\t  if you want have more cores ,you can set it larger value ,\n      the program may run faster.\n      \\t  change features.sd.threshold may have suprise. it's good encough\n      to the data of rat's liver.\n      \\n\")\n}\n\ndivide.files.by.periods <- function(state,file.path){\n  matrix.table <- read.table(file.path,header=TRUE,sep=\"\")\n  period.name <- \"\"\n  z <- c((1-PERIOD.SAMPLE.COUNT):1)  \n  \n  foreach(i = 1:PERIOD.COUNT) %dopar% {\n    z <- z+PERIOD.SAMPLE.COUNT*i\n    z[1]<-1 #row name\n    \n    period.name <- paste(state,\"_matrix_table_\",i,\".txt\",sep=\"\")\n    # the matrix in each state in every period\n    write.table(matrix.table[z],file=period.name,\n                row.names = FALSE,\n                sep=\"\\t\")\n  }\n}\n\nsd.test <- function(file.name,features.sd.threshold=0.001){\n  case.period.matrix.table <- read.table(paste(\"case_\",file.name,\".txt\",sep=\"\"),\n                                         header=TRUE,sep=\"\")  \n  control.period.matrix.table <- read.table(paste(\"control_\",file.name,\".txt\",sep=\"\"),\n                                            header=TRUE,sep=\"\")  \n  z <- c(2:(PERIOD.SAMPLE.COUNT+1))\n  \n  case.sd <- apply(case.period.matrix.table[,z],1,sd) \n  control.sd <- apply(control.period.matrix.table[,z],1,sd)\n  \n  no.zero.index <- which((case.sd != 0) & (control.sd != 0))\n  \n  gene.sd <- case.sd[no.zero.index]/control.sd[no.zero.index]\n  gene.sd.log <- log(gene.sd)\n  gene.sd.log.p <- unlist(lapply(gene.sd.log,pnorm,mean=mean(gene.sd.log),sd=sd(gene.sd.log)))\n  high.sd.index <- which((gene.sd.log.p <= features.sd.threshold) | (gene.sd.log.p >= (1-features.sd.threshold))) \n  source.high.sd.index <- no.zero.index[high.sd.index]\n  #li's method\n  #   sd.log.threshold <- pnorm(features.sd.threshold/2,mean=mean(gene.sd.log),sd=sd(gene.sd.log))\n  #   high.sd.index <- which(abs(gene.sd.log) >= sd.log.threshold)\n  \n  #  all genes \n  write.table(case.period.matrix.table[,1],\n              paste(file.name,\"_all_genes.txt\",sep=\"\"),\n              row.names=FALSE,\n              quote = FALSE,\n              sep=\"\\t\")\n  # the valid genes \n  write.table(case.period.matrix.table[no.zero.index,1],\n              paste(file.name,\"_genes.txt\",sep=\"\"),\n              row.names=FALSE,\n              quote = FALSE,\n              sep=\"\\t\")\n  # the sd of genes \n  write.table(gene.sd,\n              paste(file.name,\"_sd.txt\",sep=\"\"),\n              row.names=FALSE,\n              sep=\"\\t\")\n  # the sd of genes which has a big value\n  write.table(gene.sd[high.sd.index],\n              paste(file.name,\"_high_sd.txt\",sep=\"\"),\n              row.names=FALSE,\n              sep=\"\\t\")\n  # the sd of case data which has a big value\n  write.table(case.sd[source.high.sd.index],\n              paste(\"case_\",file.name,\"_high_sd.txt\",sep=\"\"),\n              row.names=FALSE,\n              sep=\"\\t\")\n  # the sd of control data which has a big value\n  write.table(control.sd[source.high.sd.index],\n              paste(\"control_\",file.name,\"_high_sd.txt\",sep=\"\"),\n              row.names=FALSE,\n              sep=\"\\t\")\n  # the case data whose sd has a big value\n  write.table(case.period.matrix.table[source.high.sd.index,],\n              paste(\"case_\",file.name,\"_with_high_sd.txt\",sep=\"\"),\n              row.names=FALSE,\n              sep=\"\\t\")\n  # the  control data whose sd has a big value\n  write.table(control.period.matrix.table[source.high.sd.index,],\n              paste(\"control_\",file.name,\"_with_high_sd.txt\",sep=\"\"),\n              row.names=FALSE,\n              sep=\"\\t\")\n}\n\nsd.test.with.one.state <- function(file.name,features.sd.threshold=0.001){\n  case.period.matrix.table <- read.table(paste(\"case_\",file.name,\".txt\",sep=\"\"),\n                                         header=TRUE,sep=\"\")  \n  z <- c(2:(PERIOD.SAMPLE.COUNT+1))\n  \n  case.sd <- apply(case.period.matrix.table[,z],1,sd) \n  \n  no.zero.index <- which(case.sd != 0)\n  gene.sd <- case.sd\n  gene.sd.log <- log(gene.sd)\n  gene.sd.log.p <- unlist(lapply(gene.sd.log,pnorm,mean=mean(gene.sd.log),sd=sd(gene.sd.log)))\n  high.sd.index <- which((gene.sd.log.p <= features.sd.threshold) | (gene.sd.log.p >= (1-features.sd.threshold))) \n  source.high.sd.index <- no.zero.index[high.sd.index]\n  #li's method\n  #   sd.log.threshold <- pnorm(features.sd.threshold/2,mean=mean(gene.sd.log),sd=sd(gene.sd.log))\n  #   high.sd.index <- which(abs(gene.sd.log) >= sd.log.threshold)\n  \n  # the valid genes \n  write.table(case.period.matrix.table[no.zero.index,1],\n              paste(file.name,\"_genes.txt\",sep=\"\"),\n              row.names=FALSE,\n              sep=\"\\t\")\n  # the sd of genes \n  write.table(gene.sd,\n              paste(file.name,\"_sd.txt\",sep=\"\"),\n              row.names=FALSE,\n              sep=\"\\t\")\n  # the sd of genes which has a big value\n  write.table(gene.sd[high.sd.index],\n              paste(file.name,\"_high_sd.txt\",sep=\"\"),\n              row.names=FALSE,\n              sep=\"\\t\")\n  # the sd of case data which has a big value\n  write.table(case.sd[source.high.sd.index],\n              paste(\"case_\",file.name,\"_high_sd.txt\",sep=\"\"),\n              row.names=FALSE,\n              sep=\"\\t\")\n  # the case data whose sd has a big value\n  write.table(case.period.matrix.table[source.high.sd.index,],\n              paste(\"case_\",file.name,\"_with_high_sd.txt\",sep=\"\"),\n              row.names=FALSE,\n              sep=\"\\t\")\n}\n\ncalc.pcc <- function(state,period){\n  filter.table <- read.table(paste(state,\"_matrix_table_\",period,\"_with_high_sd.txt\",sep=\"\"),\n                             header=TRUE,sep=\"\")\n  geneIds <- filter.table[,1] #as the row names and column names of matrix\n  filter.table <- filter.table[,c(2:(PERIOD.SAMPLE.COUNT+1))]\n  trans.matrix <- t(filter.table) #matrix Transpose\n  cor.matrix <- abs(cor(trans.matrix))\n  rownames(cor.matrix) <- geneIds\n  colnames(cor.matrix) <- geneIds\n  cor.matrix\n}\n\n#generate DNB \npcc.test <- function(period){\n  #control sample \n  #   control.cor.table <- read.table(paste(\"control_\",period.name,\"_cor_matrix.txt\",sep=\"\"),\n  #                              header=TRUE,sep=\"\")\n  control.cor.table <- calc.pcc(STATE[2],period)\n  #   names(control.cor.table) <- row.names(control.cor.table)\n  genes <- row.names(control.cor.table)\n  genes.number <- length(genes)\n  genes.index <- 1:genes.number\n  #matrix is more lightweight\n  #   control.cor.table <- as.matrix(control.cor.table)\n  \n  #case sample\n  #   case.cor.table <- read.table(paste(\"case_\",period.name,\"_cor_matrix.txt\",sep=\"\"),\n  #                              header=TRUE,sep=\"\")\n  case.cor.table <- calc.pcc(STATE[1],period)\n  #   names(case.cor.table) <- row.names(case.cor.table)\n  #   #matrix is more lightweight\n  #   case.cor.table <- as.matrix(case.cor.table)\n  \n  # the pcc value,as the edge\n  #   write.table(case.cor.table/control.cor.table,\n  #               paste(\"matrix_table_pcc_\"+period+\".txt\",sep=\"\"),\n  #               row.names=FALSE,\n  #               sep=\"\\t\")\n  \n  \n  model <- hclust(as.dist(1-case.cor.table))\n  cluster <- cutree(model,h = CLUSTER.HCLUST.H)\n  \n  case.sd <- read.table(paste(\"case_matrix_table_\",period,\"_high_sd.txt\",sep=\"\"),\n                        header=TRUE,\n                        sep=\"\")\n  control.sd <- read.table(paste(\"control_matrix_table_\",period,\"_high_sd.txt\",sep=\"\"),\n                           header=TRUE,\n                           sep=\"\")\n  \n  df.with.cluster.genes.sds <- cbind(cluster,genes.index,case.sd,control.sd)\n  colnames(df.with.cluster.genes.sds) <-c(\"cluster\",\"genes.index\",\"case.sd\",\"control.sd\")\n  df.aggr.by.cluster <- ddply(df.with.cluster.genes.sds,.(cluster),summarize,\n                              models = paste(genes.index,collapse=\",\"),\n                              sd = mean(case.sd)/mean(control.sd),\n                              .parallel=TRUE)\n  colnames(df.aggr.by.cluster) <-c(\"cluster\",\"models\",\"sd\")\n  \n  cluster.aggr <- df.aggr.by.cluster$cluster\n  models <- df.aggr.by.cluster$models\n  cluster.number <- length(cluster.aggr)\n  \n  \n  #the diag of table is meaningless\n  diag(control.cor.table) <- NA\n  diag(case.cor.table) <- NA\n  \n  pcc.in.mean <- numeric()\n  pcc.out.mean <- numeric()\n  \n  for(cluster.index in 1:cluster.number){\n    cur.model <- as.integer(unlist(strsplit(as.character(models[cluster.index]),\",\")))\n    model.size <- length(cur.model)\n    control.pcc.in <- as.vector(control.cor.table[cur.model,cur.model])\n    case.pcc.in <- as.vector(case.cor.table[cur.model,cur.model])\n    \n    control.pcc.out <- as.vector(control.cor.table[-cur.model,cur.model])\n    case.pcc.out <- as.vector(case.cor.table[-cur.model,cur.model])\n    \n    pcc.in.mean[cluster.index] <- (sum(case.pcc.in,na.rm=TRUE)-model.size)/(sum(control.pcc.in,na.rm=TRUE)-model.size)\n    \n    pcc.out <- cbind(control.pcc.out,case.pcc.out)\n    pcc.out <- pcc.out[order(-pcc.out[,1]),]\n    out.index <- PCC.OUT.AMOUNT*model.size\n    out.index <- ifelse(out.index<nrow(pcc.out),out.index,nrow(pcc.out))\n    pcc.out <- pcc.out[1:out.index,]\n    pcc.out.mean[cluster.index] <- mean(pcc.out[,2],na.rm=TRUE)/mean(pcc.out[,1],na.rm=TRUE)   \n  }\n  ci <- pcc.in.mean*(df.aggr.by.cluster$sd)/pcc.out.mean\n  \n  # the final CI value in the period\n  ci.max <- max(ci)\n  write.table(ci.max,\n              paste(\"matrix_table_\",period,\"_max_ci.txt\",sep=\"\"),\n              row.names=FALSE,\n              sep=\"\\t\",\n              col.names=FALSE)\n  \n  # this is the gene ids in  'DNB' ,every period have a 'DNB' ,\n  # but the real DNB is whose CI value is the maxima\n  max.model <<- genes[as.integer(unlist(strsplit(as.character(models[which.max(ci)]),\",\")))]\n  #   print(max.model)\n  #write the dnbs in current period\n  write.table(max.model,\n              paste(\"matrix_table_\",period,\"_dnb.txt\",sep=\"\"),\n              row.names=FALSE,\n              sep=\"\\t\",\n              col.names=FALSE,\n              quote=FALSE)\n}\n\n#generate DNB  for one state\npcc.test.with.one.state <- function(period){\n  case.cor.table <- calc.pcc(STATE[1],period)\n  genes <- row.names(case.cor.table)\n  genes.number <- length(genes)\n  genes.index <- 1:genes.number\n  \n  model <- hclust(as.dist(1-case.cor.table))\n  cluster <- cutree(model,h = CLUSTER.HCLUST.H)\n  \n  case.sd <- read.table(paste(\"case_matrix_table_\",period,\"_high_sd.txt\",sep=\"\"),\n                        header=TRUE,\n                        sep=\"\")\n  \n  df.with.cluster.genes.sds <- cbind(cluster,genes.index,case.sd)\n  colnames(df.with.cluster.genes.sds) <-c(\"cluster\",\"genes.index\",\"case.sd\")\n  df.aggr.by.cluster <- ddply(df.with.cluster.genes.sds,.(cluster),summarize,\n                              models = paste(genes.index,collapse=\",\"),\n                              sd = mean(case.sd))\n  colnames(df.aggr.by.cluster) <-c(\"cluster\",\"models\",\"sd\")\n  \n  cluster.aggr <- df.aggr.by.cluster$cluster\n  models <- df.aggr.by.cluster$models\n  cluster.number <- length(cluster.aggr)\n  \n  \n  #the diag of table is meaningless\n  diag(case.cor.table) <- NA\n  \n  pcc.in.mean <- numeric()\n  pcc.out.mean <- numeric()\n  \n  for(cluster.index in 1:cluster.number){\n    cur.model <- as.integer(unlist(strsplit(as.character(models[cluster.index]),\",\")))\n    model.size <- length(cur.model)\n    case.pcc.in <- as.vector(case.cor.table[cur.model,cur.model])\n    \n    case.pcc.out <- as.vector(case.cor.table[-cur.model,cur.model])\n    \n    pcc.in.mean[cluster.index] <- sum(case.pcc.in,na.rm=TRUE)-model.size\n    \n    case.pcc.out <- case.pcc.out[order(-case.pcc.out)]\n    out.index <- PCC.OUT.AMOUNT*model.size\n    out.index <- ifelse(out.index<length(case.pcc.out),out.index,length(case.pcc.out))\n    case.pcc.out <- case.pcc.out[1:out.index]\n    pcc.out.mean[cluster.index] <- mean(case.pcc.out,na.rm=TRUE)\n  }\n  ci <- pcc.in.mean*(df.aggr.by.cluster$sd)/pcc.out.mean\n  \n  # the final CI value in the period\n  ci.max <- max(ci)\n  write.table(ci.max,\n              paste(\"matrix_table_\",period,\"_max_ci.txt\",sep=\"\"),\n              row.names=FALSE,\n              sep=\"\\t\",\n              col.names=FALSE)\n  \n  # this is the gene ids in  'DNB' ,every period have a 'DNB' ,\n  # but the real DNB is whose CI value is the maxima\n  max.model <<- genes[as.integer(unlist(strsplit(as.character(models[which.max(ci)]),\",\")))]\n  #   print(max.model)\n  #write the dnbs in current period\n  write.table(max.model,\n              paste(\"matrix_table_\",period,\"_dnb.txt\",sep=\"\"),\n              row.names=FALSE,\n              sep=\"\\t\",\n              col.names=FALSE,\n              quote=FALSE)\n}\n\n#find the maxima values of an arrayL\nfindMaxima <- function(array){\n  which(diff(c(1,sign(diff(array)),-1)) == -2)\n}\n\nplot.ci <- function(){\n  \n  ci <<- numeric()# this is the final CI result of all periods\n  periods <-1:PERIOD.COUNT\n  for(i in periods){\n    \n    period.name <- paste(\"matrix_table_\",i,\"_max_ci.txt\",sep=\"\")\n    ci[i] <<- read.table(period.name)\n  }\n  names(ci) <<- as.character(seq(length(ci)))\n  print(\"ci table:\")\n  print(as.table(unlist(ci)))\n  write.table(ci,\n              \"all_ci.txt\",\n              row.names=FALSE,\n              sep=\"\\t\",\n              col.names=names(ci),\n              quote=FALSE)\n  ci.maxima.index <- findMaxima(unlist(ci))# this is period index where DNB in\n  print(\"ci maxima index:\")\n  names(ci.maxima.index) <- as.character(ci.maxima.index)\n  print(ci.maxima.index)\n  write.table(t(ci.maxima.index),\n              \"ci_maxima_index.txt\",\n              row.names=FALSE,\n              sep=\"\\t\",\n              col.names=FALSE,\n              quote=FALSE)\n  png(\"ci.png\")\n  plot(periods,unlist(ci),\n       xlab=\"period \",\n       ylab=\"ci\",\n       main=\"ci growth\",\n       type=\"b\")\n  dev.off()\n}\n\ngdm <- function(){\n  \n  if(is.null(CASE.FILE.PATH)){\n    stop(\"you should set --case.file.path\")\n  }else{\n    if(is.null(CONTROL.FILE.PATH)){\n      STATE.COUNT <<- 1 #no control data\n    }\n  }\n  \n  registerDoParallel(cores=CORES)  \n  divide.files.by.periods(STATE[1],CASE.FILE.PATH)\n  \n  if(STATE.COUNT == 2){\n    divide.files.by.periods(STATE[2],CONTROL.FILE.PATH)\n    \n    foreach (period = 1:PERIOD.COUNT) %dopar% {\n      file.name <- paste(\"matrix_table_\",period,sep=\"\")\n      sd.test(file.name=file.name,features.sd.threshold=FEATURES.SD.THRESHOLD)\n      pcc.test(period)\n    }\n  }else{# one state\n    foreach (period = 1:PERIOD.COUNT) %dopar% {\n      file.name <- paste(\"matrix_table_\",period,sep=\"\")\n      sd.test.with.one.state(file.name=file.name,features.sd.threshold=FEATURES.SD.THRESHOLD)\n      pcc.test.with.one.state(period)\n    }\n  }\n  plot.ci()\n}\n\nmain <- function(){\n\n  args <- commandArgs(TRUE)\n  print(args)\n  if ((length(args) %% 2 != 0) ){\n    print.usage()\n  }else {\n    if(length(args) != 0){\n      init(args)\n    }\n    \n    setwd(BASE.PATH)\n    print(paste(\"working directory : \" , BASE.PATH))\n    \n    gdm()\n  }\n}\n# main()\nsystem.time(main())\n",
    "created" : 1429153878965.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3729082461",
    "id" : "EA811FCF",
    "lastKnownWriteTime" : 1429179054,
    "path" : "~/DNBWorkspace/DrawPic/src/main/java/core/gdm4Par.R",
    "project_path" : "src/main/java/core/gdm4Par.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}